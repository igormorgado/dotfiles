# Declare useful functions on environment

# For add and app env variables, should be nice add a verification
# if the new value already exists, this will avoid useless (and ugly)
# duplication.

function addpath() {
	# Insert (in the beginning) a dir to ${PATH} (only if exists)
    [ -d "${1}" ] && export PATH="${1}:${PATH}"
}

function apppath() {
# Append (in the end) a dir to ${PATH} (only if exists)
    [ -d "${1}" ] && export PATH="${PATH}:${1}"
}

function addlibpath() {
	[ -d "${1}" ] && export LD_LIBRARY_PATH=${1}:${LD_LIBRARY_PATH}
}


function addrunpath() {
	[ -d "${1}" ] && export LD_RUN_PATH=${1}:${LD_RUN_PATH}

}

function addpkgpath() {
	[ -d "${1}" ] && export PKG_CONFIG_PATH=${1}:${PKG_CONFIG_PATH}

}


function loadresource() {
# Load resource only if exists
	[ -f "${1}" ] && source "${1}"
}

function lsbytesum() {
find . -maxdepth 1 -printf "%s\n" | awk '
function human(x) {
	s="B KBMBGBTBEBPBYBZB"; 
	
	while ( x>=1024 && length(s)>2 ) { 
		x/=1024;
		s=substr(s,3);
	} 
	
	return sprintf("%.2f %s",x,substr(s,1,2)) }
	
	{ SUM+=$1 } END { printf "%s\n",human(SUM) }' 
}

function parse_git_branch() {
	git branch 2> /dev/null | grep '*' | sed 's#*\ \(.*\)#(git::\1)#'
}


function parse_svn_repository_root() {
	svn info 2>/dev/null | sed -ne 's#^Repository Root: ##p'
}


function parse_svn_url() {
	svn info 2>/dev/null | sed -ne 's#^URL: ##p'
}


function parse_svn_branch() {
	parse_svn_url | \
	sed -e 's#^'"$(parse_svn_repository_root)"'##g' | \
	awk -F / '{print "(svn::"$1 "/" $2 ")"}'
}


function colortest() {
    echo -e "
    ${BLACK}BLACK       ${DGRAY}DGRAY     
    ${RED}RED           ${LRED}LRED       
    ${GREEN}GREEN       ${LGREEN}LGREEN   
    ${BROWN}BROWN       ${YELLOW}YELLOW   
    ${BLUE}BLUE         ${LBLUE}LBLUE     
    ${PURPLE}PURPLE     ${LPURPLE}LPURPLE 
    ${CYAN}CYAN         ${LCYAN}LCYAN     
    ${LGRAY}LGRAY       ${WHITE}WHITE     
    ${CRST}RESET
    "
}


# Colorize prompt based on last RETVAL
function prevCmd() {
    if [ "${1}" == 0 ] ; then
        echo "${GREEN}"
    else
        echo "${RED}"
    fi
}


function bash_prompt_command() {
    RETVAL="$?"
	history -a
	history -c
	history -r
	settitle "$(whoami)@$(hostname):$(pwd)"
    prevCmd=$(prevCmd ${RETVAL})
}


# Solarize me
function solarized_light() {
	if [ -f ~/dotfiles/_dir_colors.ansi-light ]; then
		pushd ~/dotfiles
		rm _dir_colors
		ln -s _dir_colors.ansi-light _dir_colors
		eval "$(dircolors -b _dir_colors)" 
		popd
	fi
}


function solarized_dark(){
	if [ -f ~/dotfiles/_dir_colors.ansi-dark ]; then
		pushd ~/dotfiles
		rm _dir_colors
		ln -s _dir_colors.ansi-dark _dir_colors
		eval "$(dircolors -b _dir_colors)"
		popd 
	fi
    }



function dedup() {
    fdupes -rnNd .
}


function settitle () { 
	case "${TERM}" in
		xterm*)
			echo -ne "\e]2;${*}\a\e]1;${*}\a"; 
			;;
		*) ;;
	esac
}


function cd_func () {
	local x2 the_new_dir adir index
	local -i cnt

	if [[ $1 ==  "--" ]]; then
		dirs -v
		return 0
	fi

	the_new_dir=${1}
	[[ -z $1 ]] && the_new_dir=$HOME

	if [[ ${the_new_dir:0:1} == '-' ]]; then
		#
		# Extract dir N from dirs
		index=${the_new_dir:1}
		[[ -z $index ]] && index=1
		adir=$(dirs +$index)
		[[ -z $adir ]] && return 1
		the_new_dir=$adir
	fi

	#
	# '~' has to be substituted by ${HOME}
	[[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

	#
	# Now change to the new dir and add to the top of the stack
	pushd "${the_new_dir}" > /dev/null
	[[ $? -ne 0 ]] && return 1
	the_new_dir=$(pwd)

	#
	# Trim down everything beyond 11th entry
	popd -n +11 2>/dev/null 1>/dev/null

	#
	# Remove any other occurence of this dir, skipping the top of the stack
	for ((cnt=1; cnt <= 10; cnt++)); do
		x2=$(dirs +${cnt} 2>/dev/null)
		[[ $? -ne 0 ]] && return 0
		[[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
		if [[ "${x2}" == "${the_new_dir}" ]]; then
			popd -n +$cnt 2>/dev/null 1>/dev/null
			cnt=$(( cnt-1 ))
		fi
	done

	return 0
}

function create_test_dir() {
	# Missing sockets, pipes, char, block, fifo, brokenlink
	
	local d=test_dir
	mkdir -m 775 -p "${d}/common"
	mkdir -m 2775 -p "${d}/group"
	mkdir -m 2755 -p "${d}/group_broken"
	mkdir -m 755 -p  "${d}/directory"
	mkdir -m 1777 -p "${d}/directoryt"
	mkdir -m 1775 -p "${d}/directory+t_o+w"

	declare -a testfiles
	testfiles=(archive.tar archive.tar.gz audio.ogg backup.bak
	document.pdf executable_file file1.ogg file2 file2.bak file3
	file_ex image.png logfile.log setgid_g+s setuid_u+s ttt.JPG
	video.mkv)
	
	for f in "${testfiles[@]}"; do
		touch "${d}/${f}"
		touch "${d}/common/${f}"
		touch "${d}/directory/${f}"
	done
	cd ${d}
	ln file3 file3.hardlink	
	ln -s file3 file3.synlink
	ln -s file_ex link
	ln -s /dev/null devnull
	ln -s /dev/sda1 devsda1
	ln -s directory directory_link
	ln -s nonexist brokenlink 
	cd -
	chmod g+s "${d}/setgid_g+s"
	chmod u+s "${d}/setuid_u+s"
	chmod 755 "${d}/executable_file"
	chmod 755 "${d}/file_ex"
}

# Commit all files from argument
function gca() {
	git commit -a -m "$*"
}

# Exclude files from ignore list
function gle() {
	echo "# Global"
	[ -f "${HOME}/.config/git/ignore" ] && \
	git ls-files -i --exclude-from="${HOME}/.config/git/ignore"
	echo "# Local"
	[ -f ".gitignore" ] && \
	git ls-files -i --exclude-from=.gitignore
}

function lower() {
	echo "${@}" | tr "[:upper:]" "[:lower:]"
}


function upper() {
	echo "${@}" | tr "[:lower:]" "[:upper:]"
}

function proxy_on() {
    export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com"

    if (( "${#}" > 0 )); then
        valid=$(echo "${@}" | sed -n 's/\([0-9]\{1,3\}.\)\{4\}:\([0-9]\+\)/&/p')
        if [[ "${valid}" != "${@}" ]]; then
            >&2 echo "Invalid address"
            return 1
        fi

        export http_proxy="http://$1/"
        export https_proxy=$http_proxy
        export ftp_proxy=$http_proxy
        export rsync_proxy=$http_proxy
    export HTTP_PROXY=$http_proxy
    export HTTPS_PROXY=$http_proxy
    export FTP_PROXY=$http_proxy
    export RSYNC_PROXY=$http_proxy
        echo "Proxy environment variable set."
        return 0
    fi

	echo "You can pass the proxy data as parameter to function. Anyway..."
	echo 
    echo -n "username: "; read username
    if [[ $username != "" ]]; then
        echo -n "password: "
        read -es password
        local pre="$username:$password@"
    fi

    echo -n "server: "; read server
    echo -n "port: "; read port
    export http_proxy="http://$pre$server:$port/"
    export https_proxy=$http_proxy
    export ftp_proxy=$http_proxy
    export rsync_proxy=$http_proxy
    export HTTP_PROXY=$http_proxy
    export HTTPS_PROXY=$http_proxy
    export FTP_PROXY=$http_proxy
    export RSYNC_PROXY=$http_proxy
}

function proxy_off(){
    unset http_proxy
    unset https_proxy
    unset ftp_proxy
    unset rsync_proxy
    unset HTTP_PROXY
    unset HTTPS_PROXY
    unset FTP_PROXY
    unset RSYNC_PROXY
    echo -e "Proxy environment variable removed."
}

# vim: ft=sh:
